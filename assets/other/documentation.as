
Math.random().toString(36).slice(2);

<div class="page-header">
        <h1> Список покупок </h1>
    </div>
    <div class="panel">
        <div class="form-inline">
            <div class="form-group">
                <div class="col-md-8">
                    <input class="form-control" [(ngModel)]="text" placeholder = "Название" />
                </div>
            </div>
            <div class="form-group">
                <div class="col-md-6">
                    <input type="number" class="form-control" [(ngModel)]="price" placeholder="Цена" />
                </div>
            </div>
            <div class="form-group">
                <div class="col-md-offset-2 col-md-8">
                    <button class="btn btn-default" (click)="addItem(text, price)">Добавить</button>
                </div>
            </div>
        </div>
        <table class="table table-striped">
            <thead>
                <tr>
                    <th>Предмет</th>
                    <th>Цена</th>
                    <th>Куплено</th>
                </tr>
            </thead>
            <tbody>
                <tr *ngFor="let item of items">
                    <td>{{item.purchase}}</td>
                    <td>{{item.price}}</td>
                    <td><input type="checkbox" [(ngModel)]="item.done" /></td>
                </tr>
            </tbody>
        </table>
    </div>




ng-content
Элемент ng-content позволяет внедрять родительским компонентам код html в дочерние компоненты. Так, изменим компонент ChildComponent следующим образом:


import { Component } from '@angular/core';

@Component({
    selector: 'child-comp',
    template: `<ng-content></ng-content>
                <p>Привет {{name}}</p>`,
    styles: [`h2, p {color:navy;}`]
})
export class ChildComponent {
    name= "Евгений";
}

import { Component } from '@angular/core';

@Component({
    selector: 'my-app',
    template: `<child-comp><h2>Добро пожаловать {{name}}!</h2></child-comp>`,
    styles: [`h2, p {color:#333;}`]
})
export class AppComponent {
    name = 'Tom';
}




// Однострочное сравнение
variable = (условие) ? если правда : иначе;

variable = (условие) ? если правда : (иначе если) ? если правда : иначе;;


//***************************************************************************
//*
//*  ЗАГОЛОВОК
//*
//***************************************************************************


//===========================================================================
// ТЕМАТИКА
//===========================================================================


// ОТДЕЛЯЮЩАЯ СТРОКА
//===========================================================================





//***************************************************************************
//*
//*  Git
//*
//***************************************************************************


git add // Команда git add добавляет содержимое рабочей директории в индекс (staging area) для последующего коммита. По умолчанию git commit использует лишь этот индекс, так что вы можете использовать git add для сборки слепка вашего следующего коммита.

git status // Команда git status показывает состояния файлов в рабочей директории и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе. Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.

git diff // Команда git diff используется для вычисления разницы между любыми двумя Git деревьями. Это может быть разница между вашей рабочей директорией и индексом (собственно git diff), разница между индексом и последним коммитом (git diff --staged), или между любыми двумя коммитами (git diff master branchB).


git difftool // Команда git difftool просто запускает внешнюю утилиту сравнения для показа различий в двух деревьях, на случай если вы хотите использовать что-либо отличное от встроенного просмотрщика git diff.

git commit // Команда git commit берёт все данные, добавленные в индекс с помощью git add, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок.

git reset // Команда git reset, как можно догадаться из названия, используется в основном для отмены изменений. Она изменяет указатель HEAD и, опционально, состояние индекса. Также эта команда может изменить файлы в рабочей директории при использовании параметра --hard, что может привести к потере наработок при неправильном использовании, так что убедитесь в серьёзности своих намерений прежде чем использовать его.

git rm // Команда git rm используется в Git для удаления файлов из индекса и рабочей директории. Она похожа на git add с тем лишь исключением, что она удаляет, а не добавляет файлы для следующего коммита.

git mv // Команда git mv — это всего лишь удобный способ переместить файл, а затем выполнить git add для нового файла и git rm для старого.

git clean // Команда git clean используется для удаления мусора из рабочей директории. Это могут быть результаты сборки проекта или файлы конфликтов слияний.

//***************************************************************************
//*
//*  Angular
//*
//***************************************************************************


//===========================================================================
// КОМАНДЫ
//===========================================================================

//===========================================================================
// Команда помощник. Показывает все команды ng
ng help

ls // Посмотреть директорию (не работает на node.js, нужно запускать их Git bash)

cd directory // переход в директорию

cd Desktop // перейти в диеркторию Desktop


//===========================================================================
// - Добавляет поддержку внешней библиотеки в проект.

ng add <collection> [options]

<collection> // Пакет, который нужно добавить.


--defaults=true|false //Если значение true, отключает интерактивный ввод запросов для параметров по умолчанию.

--help=true|false|json|JSON //Показывает сообщение справки для этой команды в консоли. По умолчанию: false

--interactive=true|false //Если false, отключает интерактивные приглашения ввода.

// Пример
// Добавляет пакет npm для опубликованной библиотеки в рабочую область и настраивает значение по умолчанию проект приложения для использования этой библиотеки любым способом, указанным в схеме библиотеки. Например, добавление @angular/pwaнастраивает проект для поддержки PWA:
ng add @angular/pwa
/




ng g component my-app1 --prefix --flat // эквивалентно ng generate component my-app1 --prefix --flat


Полный список сущностей, которые могут быть созданы с помощью ng generate:
class;
enum;
interface;
component;
directive;
pipe;
service;
guard;
module;
application;
library;
universal.





Интерполяция
<p>Hello, {{name}}</p>

<p>{{'Hello,' + name}}</p>

<p>{{printGreeting()}}</p>





export class HelloWorldComponent {
  name = 'World';

  printGreeting(hero: Hero): string {
  return 'Hello,' + this.name;
  }
}



/*Здесь нажатие мышкой кнопки с надписью "Show Contacts List" инициирует вызов метода showContacts().*/
<button (click)="showContacts()">Show Contacts List</button>


<button on-click="showContacts()">Show Contacts List</button>

Свойства объекта $event:

    target - элемент DOM, выступивший инициатором;
    target.value - значение элемента DOM (справедливо для полей формы);
    keyCode - код клавиши (справедливо для keyup).

<button on-click="showContacts($event)">Show Contacts List</button>


Наиболее распространенные события:

    click - нажатие кнопки мыши;
    mouseenter/mouseleave - наведение/уход курсора мыши на/с элемента;
    change - изменение состояние элемента, применяется к полям формы;
    focus - элемента получает фокус, т.е. становится активным;
    blur - потеря элементом фокуса;
    keyup - возникает, когда отпускается нажатая клавиша.




1. Создание проекта

• Сперва создадим сам проект

ng new <project_name>

• Переходим в директорию проекта

cd <project_name>

• Запускаем проект

ng serve

• Чтобы открыть проект в браузере, вводим в браузерную строку http://localhost:4200

• Чтобы отключить проектирование в браузере и вернуться к редактированию нужно нажать ctrl + c

// Когда запускается проект, сперва запускается index.html
// Внутри index.html Есть разметка HTML, но компонент вызывает другой компонент через selector <app-root></app-root>



// В каждом компоненте есть selector. В нашем случае, этот selector
@Component({
  selector: 'app-root', // название селектора
  templateUrl: './app.component.html', //путь до html файла
  styleUrls: ['./app.component.css'] // путь для стиля компонента
})




2. Добавление и редактирование компонентов и их содержимое


• Чтобы создать новый компонент нужно прописать в консоль:

ng g component <component_name>

Метод  RouterModule.forRoot()  возвращает модуль, который содержит сконфигурированный сервис Router. Когда приложение загружается, Router выполняет начальную навигацию по текущему URL, который стоит в адресной строке браузера.


"**", где две звездочки представляют любой путь.


import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';

import { Routes, RouterModule} from '@angular/router';

import { AppComponent } from './app.component';
import { AboutComponent } from './about/about.component';
import { HomeComponent } from './home/home.component';
import { NotFoundComponent } from './not-found/not-found.component';



// определение маршрутов
const appRoutes: Routes =[
  { path: '', component: HomeComponent},
  { path: 'about', component: AboutComponent},
  { path: '**', component: NotFoundComponent }
];

@NgModule({
  declarations: [
    AppComponent,
    PageComponent,
    AppRoutingComponent,
    LoginRouteComponent,
    HomeRouteComponent,
    ProfileRouteComponent,
    DirectionContactsRouteComponent,
    ContactsComponent,
    ContactsListComponent,
    HooksExampleComponent,
    ContactsItemComponent,
    HelloWorldComponent,
    HomeComponent,
    AboutComponent,
    NotFoundComponent
  ],
  imports: [
    BrowserModule,
    RouterModule.forRoot(appRoutes)
  ],
  providers: [],
  bootstrap: [AppComponent]
})





Переадресация

Для переадресации указываем параметр redirectTo

const appRoutes: Routes =[
    { path: '', component: HomeComponent},
    { path: 'about', component: AboutComponent},
    { path: '**', redirectTo: '/'}
];

const appRoutes: Routes =[
    { path: '', component: HomeComponent},
    { path: 'about', component: AboutComponent},
    { path: 'contact', redirectTo: '/about', pathMatch:'full'},
    { path: '**', redirectTo: '/'}
];

Значение pathMatch:'full' указывает, что запрошенный адрес должен полностью соответствовать маршруту, то есть должно быть полное соответствие. Например, запрос /contact полностью соотвествует маршруту { path: 'contact', redirectTo: '/about', pathMatch:'full'}, поэтому будет выполняться переадресация на адрес /about.

А запрос /contact/5 не будет соответствовать этому маршруту, так как после "contact" идут другие сегменты.




/*app.module.ts*/

    import {BrowserModule} from '@angular/platform-browser';
    import {NgModule} from '@angular/core';

    import {AppComponent} from './app.component';

    @NgModule({
        declarations: [
        AppComponent
        ],
        imports: [
        BrowserModule
        ],
        providers: [],
        bootstrap: [AppComponent]
    })
    export class AppModule {}

//================================================================================

Модуль

component - отвечает за часть web-страницы и включает в себя HTML-шаблон, CSS-стили и логику поведения;
service - поставщик данных для component;
directive - преобразует определенную часть DOM заданным образом.

Корневой модуль может быть только один, но он может использовать функционал других модулей, объявленных в объекте декоратора @NgModule() в свойстве imports.


//================================================================================

@NgModule() - это декоратор, который принимает описывающий модуль объект.

Перечень свойств объекта:

declarations - компоненты (Component), директивы (Directive) и фильтры (Pipe) корневого модуля;
exports - компоненты, сервисы, директивы и фильтры, доступные для использования разработчикам, которые будут использовать ваш модуль в своих разработках;
imports - другие модули, используемые в корневом модуле;
providers - сервисы (Service) приложения;
bootstrap - имя главного компонента приложения (как правило, называется AppComponent).


//================================================================================

Компонент
Компонент - это часть интерфейса приложения с собственной логикой. Вся видимая часть Angular App реализуется с помощью компонентов, поэтому часто можно услышать, что архитектура Angular компонентная.

За создание компонента отвечает декоратор @Component(). Основные свойства объекта, который принимает декоратор:

selector - название компонента;
template (или templateUrl) - HTML-разметка в виде строки (или путь к HTML-файлу);
providers - список сервисов, поставляющих данные для компонента;
styles - массив путей к CSS-файлам, содержащим стили для создаваемого компонента.

Все компоненты в совокупности и есть Angular App.

//================================================================================

Сервис
Сервисы нужны для предоставления данных компонентам. Это могут быть не только запросы к серверу, но и функции, преобразующие исходные данные по заданному алгоритму. Они позволяют архитектуре Angular приложения быть более гибкой и масштабируемой.

Задача сервиса должна быть узкой и строго определенной.

//================================================================================

Директива
Предназначение директив - преобразование DOM заданным образом, наделение элемента поведением.

По своей реализации директивы практически идентичны компонентам, компонент - это директива с HTML-шаблоном, но с концептуальной точки зрения они различны.

Есть два вида директив:
структурные - добавляют, удаляют или заменяют элементы в DOM;
атрибуты - задают элементу другое поведение.

Они создаются с помощью декоратора @Directive() с конфигурационным объектом.

//================================================================================

Чтобы отобразить значения переменных компонента в шаблоне Angular, используются различные механизмы привязки данных:

интерполяция;
одностороннее связывание;
обработка событий;
двустороннее связывание.



//================================================================================

Интерполяция

    <p>Hello, {{name}}</p>

    <p>{{'Hello,' + name}}</p>

    <p>{{printGreeting()}}</p>

В первом случае между {{ и }} находится название свойства класса компонента, которое заменяется его значением.



Класс компонента может выглядеть так:

    export class HelloWorldComponent {
      name = 'World';

      printGreeting(hero: Hero): string{
      return 'Hello,' + this.name;
      }
    }

//================================================================================

Одностороннее связывание

Одностороннее связывание характеризуется движением данных в одном направлении, а именно из компонента в элемент DOM.

Свойство элемента DOM - это текущее значение атрибута элемента. Это может быть как стандартный HTML-атрибут, так и атрибут компонента или директивы.

<a [href]="homePageUrl">Home Page</a>

В данном случае значение из компонента передается свойству DOM href.

Механизм одностороннего связывания позволяет только устанавливать значения свойств DOM в Angular шаблоне, чтение недоступно. Также нельзя в HTML осуществлять вызов метода компонента, который не возвращает значение.

Методы, задающие определенное поведение элемента, могут вызываться при возникновении какого-либо события




NgModule определяется классом, украшенным @NgModule(). @NgModule()Декоратор-это функция, которая принимает один объект метаданных, свойства которого описывают модуль. Наиболее важными свойствами являются следующие.

declarations: Компоненты , директивы и каналы, принадлежащие этому NgModule.

exports: Подмножество объявлений, которые должны быть видны и использоваться в шаблонах компонентов других NgModules.

imports: Другие модули, экспортируемые классы которых требуются шаблонами компонентов, объявленными в этом NgModule.

providers: Создатели сервисов, которые этот NgModule вносит в глобальную коллекцию сервисов; они становятся доступными во всех частях приложения. (Можно также указать поставщиков на уровне компонентов, что часто является предпочтительным.)

bootstrap: Основное представление приложения, называемое корневым компонентом, в котором размещаются все остальные представления приложения. Только корневой NgModule должен установить bootstrap свойство.

Вот простое определение корневого NgModule.

import { NgModule }      from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
@NgModule({
  imports:      [ BrowserModule ],
  providers:    [ Logger ],
  declarations: [ AppComponent ],
  exports:      [ AppComponent ],
  bootstrap:    [ AppComponent ]
})
export class AppModule { }



AppComponent включен в exports список здесь для иллюстрации; фактически в этом примере это не нужно. Корневой NgModule не имеет никаких оснований для экспорта. Так как это основание приложения.

Angular создает, обновляет и уничтожает компоненты по мере перемещения пользователя по приложению. Ваше приложение может принимать меры в каждый момент этого жизненного цикла с помощью дополнительных крючков жизненного цикла , например ngOnInit().

@Component
Декоратор идентифицирует класс непосредственно под ним как класс компонента и определяет его метаданные. В приведенном ниже примере кода Вы можете видеть, что HeroListComponent это просто класс, без каких-либо специальных Angular обозначений или синтаксиса. Это не компонент, пока вы не добавите к нему @Component с декоратором.

@Component({
  selector:    'app-hero-list',
  templateUrl: './hero-list.component.html',
  providers:  [ HeroService ]
})
export class HeroListComponent implements OnInit {
/* . . . */
}



Component => {{ value }} => html
Component => [property]="value" => html
Component <= (event) = "handler" <= html
Component <= [(ngModel)] = "property" => html

— // линия alt + 0151


/* символы */

┐ // alt + 191
└ // alt + 192
┴ // alt + 193
┬ // alt + 194
├ // alt + 195
─ // alt + 196
┼ // alt + 197

|—






index
├ ─ app-header
├ ─ app-root
|    └ ─ router-outlet
├ ─ app-footer


|-- README.md
|-- e2e
|-- karma.conf.js
|-- node_modules
|-- package-lock.json
|-- package.json
|-- protractor.conf.js
|-- src
|-- tsconfig.json
|-- tslint.json





Зачем мне нужен сайт ?


1. Пользователь

=> Публикация новостей о проектах команды
=> Хранение и скачивание материала
=> Связь с командой
=>

2. Администратор

=> Разработка и хранение материалов
=> Хранение шаблонов для редактирования

// EDITOR CONFIG => RULES
// "component-selector": [
//     true,
//     "element",
//     "app",
//     "kebab-case"
// ],
